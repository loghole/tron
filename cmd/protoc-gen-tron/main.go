package main

import (
	"errors"
	"flag"
	"path/filepath"
	"regexp"
	"strings"
	"unicode"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/types/pluginpb"
)

var (
	ErrMultiplyService = errors.New("files with multiply services aren't supported")
	ErrInvalidPackage  = errors.New("proto package can be started on go mod name")
)

var projectName = flag.String("project_name", "", "Project name")

func main() {
	flag.Parse()

	opt := protogen.Options{
		ParamFunc: flag.CommandLine.Set,
	}

	opt.Run(func(p *protogen.Plugin) error {
		p.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)

		for _, f := range p.Files {
			if !f.Generate {
				continue
			}

			if len(f.Services) == 0 {
				continue
			}

			if len(f.Services) > 1 {
				p.Error(ErrMultiplyService)

				continue
			}

			generateTransport(p, f)
			generateImpl(p, f)
		}

		generateMain(p)

		return nil
	})
}

func generateTransport(p *protogen.Plugin, f *protogen.File) {
	var (
		service     = f.Services[0]
		descName    = service.GoName + "ServiceDesc"
		protoSource = f.Proto.GetName()
	)

	g := p.NewGeneratedFile(f.GeneratedFilenamePrefix+".pb.tron.go", f.GoImportPath)
	g.P("// Code generated by protoc-gen-tron. DO NOT EDIT.")

	if protoSource != "" {
		g.P("// source: ", protoSource)
	}

	g.P()
	g.P("package ", f.GoPackageName)
	g.P()

	g.P("import (")
	g.P(`"context"`)
	g.P(`"embed"`)
	g.P()
	g.P(`"github.com/grpc-ecosystem/grpc-gateway/v2/runtime"`)
	g.P(`"github.com/loghole/tron/transport"`)
	g.P(`"google.golang.org/grpc"`)
	g.P(")")
	g.P()

	if protoSource != "" {
		g.P("//go:embed ", protoFileName(protoSource), ".swagger.json")
	}

	g.P("var swagger embed.FS")
	g.P()

	g.P("// ", descName, " is description for the ", service.GoName, "Server.")
	g.P("type ", descName, " struct {")
	g.P("svc ", service.GoName, "Server")
	g.P("}")
	g.P()

	g.P("func New", descName, "(s ", service.GoName, "Server) ", "transport.ServiceDesc {")
	g.P("return &", descName, "{svc: s}")
	g.P("}")
	g.P()

	g.P("func(d *", descName, ") RegisterGRPC(s *grpc.Server) {")
	g.P("Register", service.GoName, "Server(s, d.svc)")
	g.P("}")
	g.P()

	g.P("func(d *", descName, ") RegisterHTTP(mux *runtime.ServeMux) {")
	g.P("Register", service.GoName, "HandlerServer(context.Background(), mux, d.svc)")
	g.P("}")
	g.P()

	g.P("func(d *", descName, ") SwaggerDef() []byte {")
	g.P(`b, _ := swagger.ReadFile("`, protoFileName(protoSource), `.swagger.json")`)
	g.P()
	g.P("return b")
	g.P("}")
	g.P()
}

func generateImpl(p *protogen.Plugin, f *protogen.File) {
	service := f.Services[0]

	if !strings.HasPrefix(f.Proto.GetPackage(), *projectName) {
		p.Error(ErrInvalidPackage)

		return
	}

	dir := filepath.Join(
		"internal",
		"app",
		implDir(f.Proto.GetPackage()),
	)

	g := p.NewGeneratedFile(filepath.Join(dir, "handler.go"), f.GoImportPath)
	g.P("// Generated by protoc-gen-tron.")

	g.P()
	g.P("package ", f.GoPackageName)
	g.P()

	g.P("import (")
	g.P(`"github.com/loghole/tron/transport"`)
	g.P()
	g.P(f.GoPackageName, ` `, f.GoImportPath)
	g.P(")")
	g.P()

	g.P("type Implementation struct {")
	g.P(f.GoPackageName, ".Unimplemented", service.GoName, "Server")
	g.P("}")
	g.P()

	g.P("func NewImplementation() *Implementation {")
	g.P("return &Implementation{}")
	g.P("}")
	g.P()

	g.P("// GetDescription is a simple alias to the ServiceDesc constructor.")
	g.P("// It makes it possible to register the service implementation @ the server.")
	g.P("func (i *Implementation) GetDescription() transport.ServiceDesc {")
	g.P("return ", f.GoPackageName, ".New", service.GoName, "ServiceDesc(i)")
	g.P("}")
	g.P()

	for _, method := range service.Methods {
		generateImplMethod(p, f, method, dir)
	}
}

func generateImplMethod(
	p *protogen.Plugin,
	f *protogen.File,
	m *protogen.Method,
	dir string,
) {
	g := p.NewGeneratedFile(filepath.Join(dir, SnakeCase(m.GoName)+".go"), f.GoImportPath)
	g.P("// Generated by protoc-gen-tron.")

	g.P()
	g.P("package ", f.GoPackageName)
	g.P()

	var (
		inputImportAlias  = p.FilesByPath[m.Input.Location.SourceFile].GoPackageName
		outputImportAlias = p.FilesByPath[m.Output.Location.SourceFile].GoPackageName
	)

	imports := make(map[protogen.GoPackageName]protogen.GoImportPath)
	imports[inputImportAlias] = m.Input.GoIdent.GoImportPath
	imports[outputImportAlias] = m.Output.GoIdent.GoImportPath

	g.P("import (")
	g.P(`"context"`)
	g.P(`"errors"`)
	g.P()

	for alias, importPath := range imports {
		g.P(alias, ` `, importPath)
	}

	g.P(")")
	g.P()

	g.P("func (i *Implementation) ", m.GoName, "(")
	g.P("ctx context.Context,")
	g.P("req *", inputImportAlias, ".", m.Input.GoIdent.GoName, ",")
	g.P(") (*", outputImportAlias, ".", m.Output.GoIdent.GoName, ", error) {")
	g.P(`return nil, errors.New("unimplemented")`)
	g.P("}")
	g.P()
}

func generateMain(p *protogen.Plugin) {
	imports := make(map[protogen.GoPackageName]protogen.GoImportPath)

	for _, file := range p.Files {
		if !file.Generate {
			continue
		}

		if len(file.Services) == 0 {
			continue
		}

		imports[file.GoPackageName] = file.GoImportPath
	}

	g := p.NewGeneratedFile(filepath.Join("cmd", *projectName, "main.go"), "main")
	g.P("package main")
	g.P()

	g.P("import (")
	g.P(`"log"`)
	g.P()
	g.P(`"` + *projectName + `/config"`)

	for alias, importPath := range imports {
		g.P("// ", alias, ` `, importPath)
	}

	g.P()
	g.P(`"github.com/loghole/tron"`)
	g.P(")")
	g.P()

	g.P("func main() {")
	g.P("app, err := tron.New(tron.AddLogCaller())")
	g.P("if err != nil {")
	g.P(`log.Fatalf("can't create app: %s", err)`)
	g.P("}")
	g.P()

	g.P("defer app.Close()")

	g.P("app.Logger().Info(config.GetExampleValue())")
	g.P()

	g.P("// Init handlers")
	g.P("var (")
	g.P(")")
	g.P()

	g.P("if err := app.WithRunOptions().Run(); err != nil {")
	g.P(`app.Logger().Fatalf("can't run app: %v", err)`)
	g.P("}")

	g.P("}")
	g.P()
}

func protoFileName(s string) string {
	f := filepath.Base(s)
	ext := filepath.Ext(f)
	return f[:len(f)-len(ext)]
}

func implDir(pkg string) string {
	parts := strings.Split(pkg, GoName(*projectName))

	if len(parts) == 0 {
		return ""
	}

	return strings.ReplaceAll(parts[1], ".", string(filepath.Separator))
}

func SnakeCase(s string) string {
	in := []rune(s)

	isLower := func(idx int) bool {
		return idx >= 0 && idx < len(in) && unicode.IsLower(in[idx])
	}

	out := make([]rune, 0, len(in)+len(in)/2)

	for i, r := range in {
		if unicode.IsUpper(r) {
			r = unicode.ToLower(r)

			if i > 0 && in[i-1] != '_' && (isLower(i-1) || isLower(i+1)) {
				out = append(out, '_')
			}
		}

		out = append(out, r)
	}

	return string(out)
}

func CamelCase(s string) string {
	return camelCase(s, false)
}

func camelCase(s string, upper bool) string {
	s = strings.TrimSpace(s)

	buffer := make([]rune, 0, len(s))

	var prev rune

	for _, curr := range s {
		if !isDelimiter(curr) {
			if isDelimiter(prev) || (upper && prev == 0) {
				buffer = append(buffer, unicode.ToUpper(curr))
			} else {
				buffer = append(buffer, unicode.ToLower(curr))
			}
		}

		prev = curr
	}

	return string(buffer)
}

func isDelimiter(ch rune) bool {
	return ch == '-' || ch == '_' || unicode.IsSpace(ch)
}

// nolint:gochecknoglobals //regexp
var (
	goNameRexp      = regexp.MustCompile(`[^a-zA-Z0-9\s_-]+`)
	firstDigitsRexp = regexp.MustCompile(`^\d+`)
)

func GoName(s string) string {
	name := goNameRexp.ReplaceAllString(strings.ReplaceAll(s, ".", "_"), "")
	name = firstDigitsRexp.ReplaceAllString(name, "")

	return name
}
